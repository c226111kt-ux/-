<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>図形プロトタイプ（修正版：ES Modules）</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { margin: 0; font-family: sans-serif; display:flex; height:100vh; }
    #canvas-container { flex:1; background:#222; }
    #ui { width:340px; padding:16px; background:#f7f7f7; box-shadow: -2px 0 6px rgba(0,0,0,0.15); overflow:auto; }
    label { display:block; margin-top:12px; font-size:14px; }
    select, input[type="color"], input[type="range"], button { width:100%; margin-top:6px; padding:6px; box-sizing:border-box; }
    p.help { font-size:13px; color:#333; margin-top:12px; }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div id="ui">
    <h3>図形教材プロトタイプ（修正版）</h3>
    <label>図形を選ぶ:
      <select id="shape-select">
        <option value="cube">立方体 (Cube)</option>
        <option value="triPrism">三角柱 (Triangular Prism)</option>
        <option value="squarePyramid">四角錐 (Square Pyramid)</option>
      </select>
    </label>
    <label>選択フェース:
      <select id="face-select"></select>
    </label>
    <label>色を選ぶ:
      <input type="color" id="color-picker" value="#ff0000">
    </label>
    <button id="apply-color">色を適用</button>
    <label>全体スケール:
      <input type="range" id="scale" min="0.3" max="2.5" step="0.01" value="1">
    </label>
    <label>展開図アニメーション:
      <button id="toggle-unfold">展開 / 折りたたみ</button>
    </label>
    <label>リセット:
      <button id="reset">初期化</button>
    </label>
    <p class="help">操作: マウスで回転・ズーム・パン。面をクリックして選択、またはドロップダウンで選んで色を変えます。</p>
  </div>

  <!-- ES Module 版 three と OrbitControls を直接 import -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.155.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.155.0/examples/jsm/controls/OrbitControls.js';

    // ここからは元のスクリプトロジックをモジュール向けに使えるように最小限調整
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);
    const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
    camera.position.set(3, 2, 3);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(container.clientWidth, container.clientHeight);
    // 短期対処: r150+ のライト警告を抑えるためレガシー照明を有効にする
    renderer.useLegacyLights = true;
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // 照明（従来通り）
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.95);
    hemi.position.set(0, 4, 0);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(5, 10, 7.5);
    scene.add(dir);

    // --- 以下はあなたの既存ロジックをほぼそのまま流用できます ---
    let shapeGroup = new THREE.Group(); scene.add(shapeGroup);
    const ray = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    let faceMeshes = {}, defaultColors = {}, unfolded = false, currentShape = 'cube';
    const faceSelectElem = document.getElementById('face-select');
    const shapeSelect = document.getElementById('shape-select');
    const colorPicker = document.getElementById('color-picker');

    function clearGroup(g){
      while(g.children.length){
        const c = g.children[0];
        if(c.geometry) c.geometry.dispose();
        if(c.material && c.material.dispose) c.material.dispose();
        g.remove(c);
      }
    }

    function buildCube(){
      clearGroup(shapeGroup);
      faceMeshes = {};
      defaultColors = {
        front:'#ffffff', back:'#eeeeee', left:'#ddddff', right:'#ddffdd', top:'#ffffcc', bottom:'#ffdddd'
      };
      const size = 1, half = size/2;
      const faces = [
        {name:'front', pos:[0,0,half], rot:[0,0,0]},
        {name:'back',  pos:[0,0,-half], rot:[0,Math.PI,0]},
        {name:'left',  pos:[-half,0,0], rot:[0,-Math.PI/2,0]},
        {name:'right', pos:[half,0,0], rot:[0,Math.PI/2,0]},
        {name:'top',   pos:[0,half,0], rot:[-Math.PI/2,0,0]},
        {name:'bottom',pos:[0,-half,0], rot:[Math.PI/2,0,0]}
      ];
      faces.forEach(f=>{
        const geom = new THREE.PlaneGeometry(size, size);
        const mat = new THREE.MeshStandardMaterial({ color: defaultColors[f.name], side:THREE.DoubleSide });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.name = f.name;
        mesh.position.set(...f.pos);
        mesh.rotation.set(...f.rot);
        shapeGroup.add(mesh);
        faceMeshes[f.name] = mesh;
      });
      const edges = new THREE.LineSegments(
        new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size)),
        new THREE.LineBasicMaterial({color:0x222222})
      );
      shapeGroup.add(edges);
      const targets = {
        front: {pos:[0,0,half], rot:[0,0,0]},
        right: {pos:[size + size/2,0,0], rot:[-Math.PI/2,0,0]},
        left:  {pos:[-size - size/2,0,0], rot:[Math.PI/2,0,0]},
        top:   {pos:[0, size + size/2,0], rot:[0,0,0]},
        bottom:{pos:[0,-size - size/2,0], rot:[Math.PI,0,0]},
        back:  {pos:[size*2 + size/2,0,0], rot:[-Math.PI/2,0,0]}
      };
      return {origFaces:faces, targets};
    }

    // （省略）三角柱・四角錐など他の build 関数は元のまま流用可能です。
    // ここでは最小限で動作確認できるように立方体だけを用意します。
    function populateFaceSelect(){
      faceSelectElem.innerHTML = '';
      Object.keys(faceMeshes).forEach(k=>{
        const opt = document.createElement('option');
        opt.value = k; opt.textContent = k;
        faceSelectElem.appendChild(opt);
      });
    }

    function onPointerDown(event){
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((event.clientX - rect.left)/rect.width)*2 - 1;
      pointer.y = -((event.clientY - rect.top)/rect.height)*2 + 1;
      ray.setFromCamera(pointer, camera);
      const intersects = ray.intersectObjects(Object.values(faceMeshes));
      if(intersects.length>0){
        const name = intersects[0].object.name;
        faceSelectElem.value = name;
      }
    }
    renderer.domElement.addEventListener('pointerdown', onPointerDown);

    document.getElementById('apply-color').addEventListener('click', ()=>{
      const name = faceSelectElem.value;
      if(name && faceMeshes[name]) faceMeshes[name].material.color.set(colorPicker.value);
    });

    shapeSelect.addEventListener('change', (e)=>{
      buildShape(e.target.value);
    });

    document.getElementById('scale').addEventListener('input', (e)=>{
      const s = parseFloat(e.target.value);
      shapeGroup.scale.set(s,s,s);
    });

    // simple buildShape wrapper
    let currentMeta = null;
    function buildShape(name){
      currentShape = name;
      if(name === 'cube') currentMeta = buildCube();
      // 他の形は必要ならここに追加
      populateFaceSelect();
      unfolded = false;
      return currentMeta;
    }

    buildShape('cube');

    function onWindowResize(){
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    }
    window.addEventListener('resize', onWindowResize);

    function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

  </script>
</body>
</html>
