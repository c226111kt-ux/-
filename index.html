<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>図形プロトタイプ（Babylon.js） - チェーン展開対応</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{--ui-w:360px}
    html,body{height:100%;margin:0}
    body{display:flex;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN","メイリオ",sans-serif;height:100vh;overflow:hidden}
    #canvas-container{flex:1;background:#222;position:relative}
    #ui{width:var(--ui-w);padding:16px;background:#f7f7f7;box-shadow:-2px 0 6px rgba(0,0,0,0.12);overflow:auto}
    label{display:block;margin-top:12px;font-size:14px}
    select,input[type="color"],input[type="range"],button{width:100%;margin-top:6px;padding:8px;box-sizing:border-box}
    .help{font-size:13px;color:#333;margin-top:12px}
    button{cursor:pointer}
    #color-strip{height:8px;background:#fff;margin-top:6px;border:1px solid #ccc}
  </style>
</head>
<body>
  <div id="canvas-container">
    <canvas id="renderCanvas" touch-action="none" style="width:100%;height:100%;display:block"></canvas>
  </div>

  <div id="ui">
    <h3>図形教材プロトタイプ（Babylon.js）</h3>

    <label>図形を選ぶ:
      <select id="shape-select">
        <option value="cube">立方体 (Cube)</option>
        <option value="triPrism">三角柱 (Triangular Prism)</option>
        <option value="squarePyramid">四角錐 (Square Pyramid)</option>
      </select>
    </label>

    <label>選択フェース:
      <select id="face-select"></select>
    </label>

    <label>色を選ぶ:
      <input type="color" id="color-picker" value="#ff0000">
      <div id="color-strip"></div>
    </label>
    <button id="apply-color">色を適用</button>

    <label>全体スケール:
      <input type="range" id="scale" min="0.3" max="2.5" step="0.01" value="1">
    </label>

    <label>展開図アニメーション:
      <button id="toggle-unfold">展開 / 折りたたみ</button>
    </label>

    <label>リセット:
      <button id="reset">初期化</button>
    </label>

    <p class="help">操作: マウス（ドラッグで回転、ホイールでズーム、右ドラッグでパン）。面をクリックして選択、または上のドロップダウンで面を選び色を変えます。</p>
  </div>

  <!-- Babylon.js CDN -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>

  <script>
  (function(){

    // -- 初期化 --
    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.135,0.135,0.135,1);

    const camera = new BABYLON.ArcRotateCamera('cam', Math.PI/4, Math.PI/4, 4, BABYLON.Vector3.Zero(), scene);
    camera.attachControl(canvas, true);
    camera.wheelPrecision = 50;

    const hemi = new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0,1,0), scene);
    hemi.intensity = 0.95;
    const dir = new BABYLON.DirectionalLight('dir', new BABYLON.Vector3(-0.5,-1,0.5), scene);
    dir.position = new BABYLON.Vector3(5,10,5);
    dir.intensity = 0.6;

    // root node for current shape
    let root = new BABYLON.TransformNode('root', scene);

    // 状態と UI 要素
    let faceMeshes = {}; // { name: mesh }
    let defaultColors = {};
    let unfolded = false;
    let currentShape = 'cube';
    let currentMeta = null; // { origFaces, targets }

    // pivots created during unfolding (kept to allow cleanup)
    let activePivots = [];

    const shapeSelect = document.getElementById('shape-select');
    const faceSelect = document.getElementById('face-select');
    const colorPicker = document.getElementById('color-picker');
    const colorStrip = document.getElementById('color-strip');
    const applyColorBtn = document.getElementById('apply-color');
    const scaleInput = document.getElementById('scale');
    const toggleUnfoldBtn = document.getElementById('toggle-unfold');
    const resetBtn = document.getElementById('reset');

    // helpers
    function lerp(a,b,t){ return a + (b-a)*t; }
    function lerpVec3(a,b,t){ return new BABYLON.Vector3(lerp(a.x,b.x,t), lerp(a.y,b.y,t), lerp(a.z,b.z,t)); }

    // dispose helper
    function clearRoot(){
      activePivots.forEach(p => { try{ p.dispose(); }catch(e){} });
      activePivots = [];

      for (const k in faceMeshes){
        try{ faceMeshes[k].dispose(true); }catch(e){}
      }
      faceMeshes = {};
      if(root) { root.getChildren().forEach(c=>c.dispose()); }
      root.dispose();
      root = new BABYLON.TransformNode('root', scene);
    }

    // create plane helper (size = width,height) in local plane (centered) facing +Z
    function createFacePlane(name, width=1, height=1, options = {}){
      const plane = BABYLON.MeshBuilder.CreatePlane(name, {width: width, height: height, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
      plane.parent = root;
      plane.isPickable = true;
      plane.receiveShadows = false;
      return plane;
    }

    // --- 形状構築（cube / triPrism / squarePyramid） ---
    function buildCube(){
      clearRoot();
      faceMeshes = {};
      defaultColors = {
        front:'#ffffff', back:'#eeeeee', left:'#ddddff', right:'#ddffdd', top:'#ffffcc', bottom:'#ffdddd'
      };
      const size = 1;
      const half = size/2;

      const faces = [
        {name:'front', pos:new BABYLON.Vector3(0,0,half), rot:new BABYLON.Vector3(0,0,0)},
        {name:'back',  pos:new BABYLON.Vector3(0,0,-half), rot:new BABYLON.Vector3(0,Math.PI,0)},
        {name:'left',  pos:new BABYLON.Vector3(-half,0,0), rot:new BABYLON.Vector3(0,-Math.PI/2,0)},
        {name:'right', pos:new BABYLON.Vector3(half,0,0), rot:new BABYLON.Vector3(0,Math.PI/2,0)},
        {name:'top',   pos:new BABYLON.Vector3(0,half,0), rot:new BABYLON.Vector3(-Math.PI/2,0,0)},
        {name:'bottom',pos:new BABYLON.Vector3(0,-half,0), rot:new BABYLON.Vector3(Math.PI/2,0,0)}
      ];

      faces.forEach(f=>{
        const m = createFacePlane(f.name, size, size);
        m.position.copyFrom(f.pos);
        m.rotation = f.rot.clone();
        const mat = new BABYLON.StandardMaterial('mat_'+f.name, scene);
        mat.diffuseColor = BABYLON.Color3.FromHexString(defaultColors[f.name]);
        m.material = mat;
        faceMeshes[f.name] = m;
      });

      const origFaces = faces.map(f=>({name:f.name,pos:f.pos.clone(),rot:f.rot.clone()}));
      const targets = {}; // kept for compatibility
      return {origFaces, targets};
    }

    function buildTriPrism(){
      clearRoot();
      faceMeshes = {};
      const s = 1;
      const depth = 1;
      const triH = Math.sqrt(3)/2 * s;
      const v0 = new BABYLON.Vector3(-s/2, -triH/3, 0);
      const v1 = new BABYLON.Vector3(s/2, -triH/3, 0);
      const v2 = new BABYLON.Vector3(0, triH*2/3, 0);

      defaultColors = { capFront:'#ffeeee', capBack:'#eeffee', side0:'#ffdd88', side1:'#88ddff', side2:'#88ff88' };

      function createTriFace(name, z){
        const positions = [
          v0.x, v0.y, z,
          v1.x, v1.y, z,
          v2.x, v2.y, z
        ];
        const indices = [0,1,2];
        const custom = new BABYLON.Mesh(name, scene);
        const vertexData = new BABYLON.VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        vertexData.applyToMesh(custom, true);
        custom.parent = root;
        custom.isPickable = true;
        const mat = new BABYLON.StandardMaterial('mat_'+name, scene);
        mat.diffuseColor = BABYLON.Color3.FromHexString(defaultColors[name]);
        custom.material = mat;
        faceMeshes[name] = custom;
        return custom;
      }

      createTriFace('capFront', depth/2);
      createTriFace('capBack', -depth/2);

      const sides = [
        {name:'side0', a:v0, b:v1},
        {name:'side1', a:v1, b:v2},
        {name:'side2', a:v2, b:v0}
      ];
      sides.forEach((sdat,i)=>{
        const a = sdat.a, b = sdat.b;
        const edgeCenter = a.add(b).scale(0.5);
        const edgeLen = BABYLON.Vector3.Distance(a,b);
        const pl = createFacePlane(sdat.name, edgeLen, depth);
        const angle = Math.atan2(b.y - a.y, b.x - a.x);
        pl.position = new BABYLON.Vector3(edgeCenter.x, edgeCenter.y, 0);
        pl.rotation.x = Math.PI/2;
        pl.rotation.z = angle;
        const mat = new BABYLON.StandardMaterial('mat_'+sdat.name, scene);
        mat.diffuseColor = BABYLON.Color3.FromHexString(defaultColors[sdat.name]);
        pl.material = mat;
        faceMeshes[sdat.name] = pl;
      });

      const faces = Object.keys(faceMeshes).map(name=>{
        const m = faceMeshes[name];
        return {name, pos:m.position.clone(), rot:m.rotation.clone()};
      });

      return {origFaces:faces, targets:{}};
    }

    function buildSquarePyramid(){
      clearRoot();
      faceMeshes = {};
      const base = 1;
      const half = base/2;
      const height = 1;

      defaultColors = { base:'#ffeedd', side0:'#ffd', side1:'#ddf', side2:'#dfd', side3:'#ffddee' };

      const basePlane = createFacePlane('base', base, base);
      basePlane.rotation.x = -Math.PI/2;
      basePlane.position = new BABYLON.Vector3(0,0,0);
      basePlane.material = new BABYLON.StandardMaterial('mat_base', scene);
      basePlane.material.diffuseColor = BABYLON.Color3.FromHexString(defaultColors.base);
      faceMeshes['base'] = basePlane;

      const apex = new BABYLON.Vector3(0, height, 0);
      const corners = [
        new BABYLON.Vector3(-half,0,-half),
        new BABYLON.Vector3( half,0,-half),
        new BABYLON.Vector3( half,0, half),
        new BABYLON.Vector3(-half,0, half)
      ];

      for(let i=0;i<4;i++){
        const a = corners[i], b = corners[(i+1)%4];
        const positions = [
          a.x, a.y, a.z,
          b.x, b.y, b.z,
          apex.x, apex.y, apex.z
        ];
        const geom = new BABYLON.Mesh('side'+i, scene);
        const vdata = new BABYLON.VertexData();
        vdata.positions = positions;
        vdata.indices = [0,1,2];
        vdata.applyToMesh(geom, true);
        geom.parent = root;
        geom.isPickable = true;
        const mat = new BABYLON.StandardMaterial('mat_side'+i, scene);
        mat.diffuseColor = BABYLON.Color3.FromHexString(defaultColors['side'+i]);
        geom.material = mat;
        faceMeshes['side'+i] = geom;
      }

      const faces = Object.keys(faceMeshes).map(name=>{
        const m = faceMeshes[name];
        return {name, pos:m.position.clone(), rot:m.rotation.clone()};
      });

      return {origFaces:faces, targets:{}};
    }

    // dispatcher
    function buildShape(name){
      currentShape = name;
      if(name === 'cube') currentMeta = buildCube();
      else if(name === 'triPrism') currentMeta = buildTriPrism();
      else if(name === 'squarePyramid') currentMeta = buildSquarePyramid();
      populateFaceSelect();
      unfolded = false;
      return currentMeta;
    }

    function populateFaceSelect(){
      faceSelect.innerHTML = '';
      Object.keys(faceMeshes).forEach(k=>{
        const opt = document.createElement('option');
        opt.value = k; opt.textContent = k;
        faceSelect.appendChild(opt);
      });
      faceSelect.value = faceSelect.options.length ? faceSelect.options[0].value : '';
    }

    // picking
    canvas.addEventListener('pointerdown', function(evt){
      if(evt.button !== 0) return;
      const pick = scene.pick(scene.pointerX, scene.pointerY);
      if(pick && pick.hit && pick.pickedMesh){
        const name = pick.pickedMesh.name;
        if(name in faceMeshes){
          faceSelect.value = name;
        }
      }
    });

    // color apply
    function applyColorToSelected(){
      const name = faceSelect.value;
      if(!name) return;
      const mesh = faceMeshes[name];
      if(!mesh) return;
      const hex = colorPicker.value;
      if(mesh.material && mesh.material.diffuseColor){
        mesh.material.diffuseColor = BABYLON.Color3.FromHexString(hex);
        colorStrip.style.background = hex;
      }
    }
    applyColorBtn.addEventListener('click', applyColorToSelected);
    colorPicker.addEventListener('input', ()=> colorStrip.style.background = colorPicker.value);

    // scale
    scaleInput.addEventListener('input', ()=>{
      const s = parseFloat(scaleInput.value);
      root.scaling = new BABYLON.Vector3(s,s,s);
    });

    // reset
    resetBtn.addEventListener('click', ()=>{
      buildShape(currentShape);
      root.position = BABYLON.Vector3.Zero();
      root.scaling = new BABYLON.Vector3(1,1,1);
      Object.keys(faceMeshes).forEach(name=>{
        if(defaultColors[name] && faceMeshes[name] && faceMeshes[name].material){
          faceMeshes[name].material.diffuseColor = BABYLON.Color3.FromHexString(defaultColors[name]);
        }
      });
      // dispose pivots
      activePivots.forEach(p=>{ try{ p.dispose(); }catch(e){} });
      activePivots = [];
      unfolded = false;
    });

    // --- Pivot / hinge utilities ---

    function getWorldVertices(mesh){
      const pos = mesh.getVerticesData ? mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind) : null;
      if(!pos) {
        const bb = mesh.getBoundingInfo && mesh.getBoundingInfo();
        if(bb){
          const min = bb.minimum.add(mesh.getAbsolutePosition());
          const max = bb.maximum.add(mesh.getAbsolutePosition());
          return [min, max];
        }
        return [];
      }
      const verts = [];
      const wm = mesh.getWorldMatrix();
      for(let i=0;i<pos.length;i+=3){
        const v = new BABYLON.Vector3(pos[i],pos[i+1],pos[i+2]);
        const w = BABYLON.Vector3.TransformCoordinates(v, wm);
        verts.push(w);
      }
      return verts;
    }

    function findSharedEdge(meshA, meshB, eps = 1e-3){
      const aVerts = getWorldVertices(meshA);
      const bVerts = getWorldVertices(meshB);
      const common = [];
      for(const va of aVerts){
        for(const vb of bVerts){
          if(va.subtract(vb).lengthSquared() < eps*eps){
            common.push(va.clone());
          }
        }
      }
      if(common.length < 2) return null;
      const uniq = [];
      for(const c of common){
        if(uniq.every(u => u.subtract(c).length() > eps)) uniq.push(c);
        if(uniq.length === 2) break;
      }
      if(uniq.length === 2) return {p1: uniq[0], p2: uniq[1]};
      return null;
    }

    function getWorldNormal(mesh){
      const localN = new BABYLON.Vector3(0,0,1);
      const m = mesh.getWorldMatrix();
      const worldN = BABYLON.Vector3.TransformNormal(localN, m);
      worldN.normalize();
      return worldN;
    }

    function signedAngleAroundAxis(a, b, axis){
      const axisN = axis.clone().normalize();
      const aP = a.subtract(axisN.scale(BABYLON.Vector3.Dot(axisN, a)));
      const bP = b.subtract(axisN.scale(BABYLON.Vector3.Dot(axisN, b)));
      if(aP.length() === 0 || bP.length() === 0) return 0;
      aP.normalize(); bP.normalize();
      const dot = BABYLON.Scalar.Clamp(BABYLON.Vector3.Dot(aP,bP), -1, 1);
      const cross = BABYLON.Vector3.Cross(aP, bP);
      const sign = Math.sign(BABYLON.Vector3.Dot(axisN, cross)) || 1;
      const angle = Math.acos(dot) * sign;
      return angle;
    }

    // hinge rotate returns a Promise resolved when animation completes
    function hingeRotateMeshAroundEdge(mesh, hingeP1, hingeP2, angleRad, durationMs = 600){
      return new Promise((resolve) => {
        // store world transform
        const origWorldPos = mesh.getAbsolutePosition().clone();
        const origWorldQuat = mesh.rotationQuaternion ? mesh.rotationQuaternion.clone() : BABYLON.Quaternion.FromEulerVector(mesh.rotation);

        // pivot at hinge midpoint
        const hingeMid = hingeP1.add(hingeP2).scale(0.5);
        const pivot = new BABYLON.TransformNode(mesh.name + "_hinge_pivot", scene);
        pivot.position.copyFrom(hingeMid);
        pivot.rotationQuaternion = BABYLON.Quaternion.Identity();

        // compute local pos for mesh relative to pivot
        const inv = pivot.getWorldMatrix().clone();
        inv.invert();
        const localPos = BABYLON.Vector3.TransformCoordinates(origWorldPos, inv);

        // parent mesh to pivot and set local pos/rot to preserve world transform
        mesh.setParent(pivot);
        mesh.position.copyFrom(localPos);
        mesh.rotationQuaternion = origWorldQuat;

        // axis and target quaternion
        const axis = hingeP2.subtract(hingeP1).normalize();
        const targetQuat = BABYLON.Quaternion.RotationAxis(axis, angleRad).multiply(pivot.rotationQuaternion || BABYLON.Quaternion.Identity());

        const frameRate = 60;
        const totalFrames = Math.max(1, Math.floor((durationMs / 1000) * frameRate));
        const anim = new BABYLON.Animation("anim_hinge_" + mesh.name, "rotationQuaternion", frameRate,
          BABYLON.Animation.ANIMATIONTYPE_QUATERNION, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);

        const keys = [
          { frame: 0, value: pivot.rotationQuaternion.clone() },
          { frame: totalFrames, value: targetQuat }
        ];
        anim.setKeys(keys);
        pivot.animations = pivot.animations || [];
        pivot.animations.push(anim);

        activePivots.push(pivot);

        // begin animation and resolve at end
        scene.beginAnimation(pivot, 0, totalFrames, false, 1, () => {
          resolve(pivot);
        });
      });
    }

    // --- Build adjacency graph and spanning tree, then unfold along tree sequentially ---
    function buildAdjacency(){
      const names = Object.keys(faceMeshes);
      const adj = {};
      for(const a of names) {
        adj[a] = new Set();
      }
      for(let i=0;i<names.length;i++){
        for(let j=i+1;j<names.length;j++){
          const A = faceMeshes[names[i]];
          const B = faceMeshes[names[j]];
          const edge = findSharedEdge(A,B,1e-3);
          if(edge){
            adj[names[i]].add(names[j]);
            adj[names[j]].add(names[i]);
          }
        }
      }
      // convert sets to arrays
      for(const k in adj) adj[k] = Array.from(adj[k]);
      return adj;
    }

    function buildSpanningTree(adj, rootName){
      const parent = {};
      const order = [];
      const q = [rootName];
      parent[rootName] = null;
      while(q.length){
        const u = q.shift();
        order.push(u);
        const neighbors = adj[u] || [];
        for(const v of neighbors){
          if(!(v in parent)){
            parent[v] = u;
            q.push(v);
          }
        }
      }
      return {parent, order};
    }

    // unfold tree: performs hinge rotations from parent -> child sequentially
    async function unfoldSpanningTree(rootName){
      const adj = buildAdjacency();
      const {parent, order} = buildSpanningTree(adj, rootName);
      // process nodes in order (skip root)
      for(const name of order){
        if(name === rootName) continue;
        const pName = parent[name];
        if(!pName) continue;
        const childMesh = faceMeshes[name];
        const parentMesh = faceMeshes[pName];
        if(!childMesh || !parentMesh) continue;
        const edge = findSharedEdge(childMesh, parentMesh, 1e-3);
        if(!edge){
          console.warn('no shared edge found for', name, 'and', pName);
          continue;
        }
        // compute axis and normals (world)
        const axis = edge.p2.subtract(edge.p1).normalize();
        const childNormal = getWorldNormal(childMesh);
        const parentNormal = getWorldNormal(parentMesh);

        // compute signed angle to rotate childNormal onto parentNormal around axis
        let angle = signedAngleAroundAxis(childNormal, parentNormal, axis);

        // If angle is near 0, pick +/-90 deg as a reasonable unfold outward
        const eps = 0.02;
        if(Math.abs(angle) < eps){
          // determine outward direction: vector from hinge to child center
          const childCenter = childMesh.getBoundingInfo().boundingBox.centerWorld;
          const hingeMid = edge.p1.add(edge.p2).scale(0.5);
          const toChild = childCenter.subtract(hingeMid);
          const cross = BABYLON.Vector3.Cross(axis, toChild);
          angle = (BABYLON.Vector3.Dot(cross, parentNormal) >= 0) ? Math.PI/2 : -Math.PI/2;
        }

        // Perform hinge rotation and await completion before continuing (chained)
        try{
          await hingeRotateMeshAroundEdge(childMesh, edge.p1, edge.p2, angle, 700);
        }catch(e){
          console.error('hinge animation failed for', name, e);
        }
      }
    }

    // pivot-based master unfold: builds spanning tree from center face and unfolds chain
    async function pivotUnfoldChain(){
      if(!currentMeta) return;
      const centerName = ('front' in faceMeshes) ? 'front' : Object.keys(faceMeshes)[0];
      // clear any previous pivots
      activePivots.forEach(p => { try{ p.dispose(); }catch(e){} });
      activePivots = [];
      // run unfold chain
      await unfoldSpanningTree(centerName);
    }

    // toggleUnfold uses chain unfold; fold-back rebuilds original shape
    let animFlag = false;
    async function toggleUnfold(){
      if(animFlag) return;
      animFlag = true;
      if(!unfolded){
        await pivotUnfoldChain();
        unfolded = true;
        animFlag = false;
      } else {
        // fold back: rebuild shape to restore exact original state (simple and robust)
        activePivots.forEach(p => { try{ p.dispose(); }catch(e){} });
        activePivots = [];
        buildShape(currentShape);
        unfolded = false;
        animFlag = false;
      }
    }

    toggleUnfoldBtn.addEventListener('click', toggleUnfold);

    // UI handlers
    shapeSelect.addEventListener('change', (e)=> buildShape(e.target.value) );

    // initial
    buildShape('cube');

    // render loop
    engine.runRenderLoop(() => {
      scene.render();
    });

    window.addEventListener('resize', ()=> engine.resize());

    // debug
    function logFaces(){
      console.log('faces:', Object.keys(faceMeshes));
    }
    window.__proto__._faceMeshes = faceMeshes;
    logFaces();

  })();
  </script>
</body>
</html>
